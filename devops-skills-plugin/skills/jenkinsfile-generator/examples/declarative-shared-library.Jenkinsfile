// Declarative Pipeline - Using Shared Library
// Generated by Jenkinsfile Generator
// Demonstrates shared library usage patterns

@Library('my-jenkins-library') _
import org.example.Utils
import org.example.Docker
import org.example.Notifications

pipeline {
    agent any

    environment {
        DOCKER_REGISTRY = 'registry.example.com'
        DOCKER_IMAGE = 'myapp'
    }

    options {
        buildDiscarder(logRotator(numToKeepStr: '10'))
        timestamps()
        timeout(time: 30, unit: 'MINUTES')
    }

    stages {
        stage('Checkout') {
            steps {
                checkout scm
                script {
                    // Using shared library utility class
                    env.GIT_BRANCH = Utils.getBranchName(this)
                    env.GIT_COMMIT_SHORT = Utils.getShortCommitSha(this)
                    log.info "Building branch: ${env.GIT_BRANCH} at commit: ${env.GIT_COMMIT_SHORT}"
                }
            }
        }

        stage('Validate Environment') {
            steps {
                script {
                    // Validate required environment variables using shared library
                    Utils.validateEnvVars(this, ['DOCKER_REGISTRY', 'DOCKER_IMAGE'])
                    log.success 'Environment validation passed'
                }
            }
        }

        stage('Build') {
            steps {
                script {
                    log.info 'Starting build process...'
                    sh 'mvn clean package -DskipTests'
                    log.success 'Build completed'
                }
            }
        }

        stage('Test') {
            steps {
                script {
                    log.info 'Running tests...'
                    sh 'mvn test'
                    log.success 'Tests passed'
                }
            }
            post {
                always {
                    junit '**/target/surefire-reports/*.xml'
                }
            }
        }

        stage('Security Scan') {
            steps {
                script {
                    // Using shared library security scanning function
                    securityScan(
                        sonarqube: true,
                        sonarqubeServer: 'sonarqube-server',
                        owaspDependencyCheck: true,
                        failOnCritical: true
                    )
                }
            }
        }

        stage('Docker Build') {
            steps {
                script {
                    // Using shared library Docker class
                    def dockerUtil = new Docker(
                        this,
                        env.DOCKER_REGISTRY,
                        'docker-registry-credentials'
                    )

                    // Build with commit SHA tag
                    def image = dockerUtil.build(
                        env.DOCKER_IMAGE,
                        env.GIT_COMMIT_SHORT
                    )

                    // Store image reference for later stages
                    env.DOCKER_IMAGE_TAG = "${env.DOCKER_REGISTRY}/${env.DOCKER_IMAGE}:${env.GIT_COMMIT_SHORT}"
                    log.success "Docker image built: ${env.DOCKER_IMAGE_TAG}"
                }
            }
        }

        stage('Container Security Scan') {
            steps {
                script {
                    // Scan the built container image
                    securityScan(
                        trivy: true,
                        trivyImage: env.DOCKER_IMAGE_TAG,
                        failOnCritical: true
                    )
                }
            }
        }

        stage('Push to Registry') {
            when {
                anyOf {
                    branch 'main'
                    branch 'develop'
                }
            }
            steps {
                script {
                    // Using shared library Docker build/push function
                    dockerBuild(
                        imageName: env.DOCKER_IMAGE,
                        registry: env.DOCKER_REGISTRY,
                        credentialsId: 'docker-registry-credentials',
                        tags: [env.GIT_COMMIT_SHORT, env.GIT_BRANCH, 'latest'],
                        push: true
                    )
                    log.success 'Docker image pushed to registry'
                }
            }
        }

        stage('Deploy to Staging') {
            when {
                branch 'develop'
            }
            steps {
                script {
                    // Using shared library deployment function
                    deployApp(
                        environment: 'staging',
                        kubeConfig: 'kubeconfig-staging',
                        namespace: 'myapp-staging',
                        manifests: 'k8s/staging/',
                        approval: false
                    )
                }
            }
        }

        stage('Deploy to Production') {
            when {
                branch 'main'
            }
            steps {
                script {
                    // Deployment with approval gate
                    deployApp(
                        environment: 'production',
                        kubeConfig: 'kubeconfig-production',
                        namespace: 'myapp-production',
                        manifests: 'k8s/production/',
                        approval: true
                    )
                }
            }
        }
    }

    post {
        always {
            script {
                // Using shared library notification class
                def notify = new Notifications(this)
                notify.buildStatus('#builds', 'devops-team@example.com')
            }
            cleanWs()
        }
        success {
            script {
                log.success "Pipeline completed successfully for ${env.GIT_BRANCH}"
            }
        }
        failure {
            script {
                log.error "Pipeline failed for ${env.GIT_BRANCH}"
            }
        }
    }
}