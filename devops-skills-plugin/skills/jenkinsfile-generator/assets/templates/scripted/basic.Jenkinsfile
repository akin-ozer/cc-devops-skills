// Scripted Pipeline Template
// Replace [PLACEHOLDER] values with your configuration
// Generated by Jenkinsfile Generator

// Optional: Load shared library
// @Library('my-shared-library') _

// Node selection (optional: specify label)
node('[AGENT_LABEL]') {
    // Environment setup
    def buildVersion = "${env.BUILD_NUMBER}"
    def artifactName = "[ARTIFACT_NAME]"

    try {
        stage('Checkout') {
            checkout scm
            // Or explicit checkout:
            // git branch: 'main', url: '[REPOSITORY_URL]'
        }

        stage('Build') {
            // Optional: Run inside Docker container
            // docker.image('[DOCKER_IMAGE]').inside {
            //     sh '[BUILD_COMMAND]'
            // }

            sh '[BUILD_COMMAND]'
            // Examples:
            // sh 'mvn clean compile'
            // sh 'npm install && npm run build'
            // sh 'go build ./...'
        }

        stage('Test') {
            sh '[TEST_COMMAND]'
            // Examples:
            // sh 'mvn test'
            // sh 'npm test'
            // sh 'pytest --junitxml=test-results.xml'

            // Publish test results
            junit '[TEST_RESULTS_PATH]'
            // Examples:
            // junit '**/target/surefire-reports/*.xml'
            // junit '**/test-results.xml'
        }

        stage('Package') {
            sh '[PACKAGE_COMMAND]'
            // Examples:
            // sh 'mvn package -DskipTests'
            // sh 'npm run build:prod'
        }

        // Optional: Docker Build and Push
        // stage('Docker Build') {
        //     def image = docker.build("[IMAGE_NAME]:${buildVersion}")
        //
        //     stage('Docker Push') {
        //         docker.withRegistry('[REGISTRY_URL]', '[REGISTRY_CREDENTIALS]') {
        //             image.push()
        //             image.push('latest')
        //         }
        //     }
        // }

        // Optional: Parallel Testing
        // stage('Parallel Tests') {
        //     parallel(
        //         'Unit Tests': {
        //             node {
        //                 sh 'npm run test:unit'
        //             }
        //         },
        //         'Integration Tests': {
        //             node {
        //                 sh 'npm run test:integration'
        //             }
        //         }
        //     )
        // }

        // Conditional deployment based on branch
        if (env.BRANCH_NAME == 'main') {
            stage('Deploy to Production') {
                // Wait for approval
                input message: 'Deploy to production?', submitter: '[APPROVERS]'

                sh '[DEPLOY_COMMAND]'
                // Examples:
                // sh './deploy.sh production'
                // sh 'kubectl apply -f k8s/'
            }
        } else if (env.BRANCH_NAME == 'develop') {
            stage('Deploy to Staging') {
                sh '[DEPLOY_STAGING_COMMAND]'
            }
        }

        // Archive artifacts on success
        if (currentBuild.result == null || currentBuild.result == 'SUCCESS') {
            archiveArtifacts artifacts: '[ARTIFACT_PATTERN]', fingerprint: true
            // Examples:
            // archiveArtifacts artifacts: '**/target/*.jar', fingerprint: true
        }

    } catch (Exception e) {
        currentBuild.result = 'FAILURE'
        echo "Pipeline failed: ${e.message}"

        // Optional: Send failure notification
        // emailext(
        //     subject: "Build Failed: ${env.JOB_NAME} #${env.BUILD_NUMBER}",
        //     body: "Error: ${e.message}\nCheck ${env.BUILD_URL}",
        //     to: '[EMAIL_RECIPIENTS]'
        // )

        // Optional: Slack notification
        // slackSend color: 'danger', message: "Build ${env.BUILD_NUMBER} failed"

        throw e
    } finally {
        // Always cleanup workspace
        deleteDir()
    }
}