stages:
  - .pre
  - build
  - test
  - security
  - deploy
  - .post
variables:
  CACHE_VERSION: v1
  NODE_VERSION: '18'
validate_config:
  stage: .pre
  image:
    name: alpine:latest
  script:
    - echo "Validating configuration"
    - test -f package.json || exit 1
    - test -f Dockerfile || exit 1
  tags:
    - docker
build_frontend:
  stage: build
  image:
    name: node:${NODE_VERSION}-alpine
  script:
    - echo "Building frontend"
    - cd frontend
    - npm ci
    - npm run build
  artifacts:
    paths:
      - frontend/dist/
    expire_in: 1 day
  cache:
    - key: ${CACHE_VERSION}-frontend-${CI_COMMIT_REF_SLUG}
      paths:
        - frontend/node_modules/
        - frontend/.npm/
      policy: pull-push
      when: on_success
  tags:
    - docker
build_backend:
  stage: build
  image:
    name: golang:1.21-alpine
  script:
    - echo "Building backend"
    - cd backend
    - go mod download
    - go build -o bin/server ./cmd/server
  artifacts:
    paths:
      - backend/bin/
    expire_in: 1 day
  cache:
    - key: ${CACHE_VERSION}-backend-${CI_COMMIT_REF_SLUG}
      paths:
        - /go/pkg/mod/
      policy: pull-push
      when: on_success
  tags:
    - docker
build_docs:
  stage: build
  image:
    name: python:3.11-alpine
  script:
    - echo "Building documentation"
    - pip install mkdocs mkdocs-material
    - mkdocs build
  artifacts:
    paths:
      - site/
    expire_in: 1 week
  tags:
    - docker
test_frontend_unit:
  stage: test
  image:
    name: node:${NODE_VERSION}-alpine
  needs:
    - job: build_frontend
      artifacts: true
      optional: false
  script:
    - echo "Running frontend unit tests"
    - cd frontend
    - npm ci
    - npm run test:unit
  artifacts:
    reports:
      junit: frontend/junit.xml
      coverage_report:
        coverage_format: cobertura
        path: frontend/coverage/cobertura.xml
  coverage: /Lines\s*:\s*(\d+\.\d+)%/
  tags:
    - docker
test_frontend_e2e:
  stage: test
  image:
    name: cypress/included:13.6.0
  needs:
    - job: build_frontend
      artifacts: true
      optional: false
  services:
    - name: nginx:alpine
      alias: web
  script:
    - echo "Running E2E tests"
    - cd frontend
    - npm ci
    - npm run test:e2e
  artifacts:
    when: always
    paths:
      - frontend/cypress/screenshots/
      - frontend/cypress/videos/
    expire_in: 1 week
  allow_failure: true
  tags:
    - docker
test_backend_unit:
  stage: test
  image:
    name: golang:1.21-alpine
  needs:
    - job: build_backend
      artifacts: true
      optional: false
  script:
    - echo "Running backend unit tests"
    - cd backend
    - go test -v -coverprofile=coverage.out ./...
    - go tool cover -func=coverage.out
  artifacts:
    reports:
      coverage_report:
        coverage_format: cobertura
        path: backend/coverage.xml
  coverage: /total:.*?(\d+\.\d+)%/
  tags:
    - docker
test_backend_integration:
  stage: test
  image:
    name: golang:1.21-alpine
  needs:
    - job: build_backend
      artifacts: true
      optional: false
  services:
    - name: postgres:15-alpine
      alias: postgres
    - name: redis:7-alpine
      alias: redis
  variables:
    POSTGRES_DB: testdb
    POSTGRES_USER: test
    POSTGRES_PASSWORD: test
    DATABASE_URL: postgres://test:test@postgres:5432/testdb?sslmode=disable
    REDIS_URL: redis://redis:6379
  script:
    - echo "Running backend integration tests"
    - cd backend
    - go test -v -tags=integration ./...
  tags:
    - docker
lint_frontend:
  stage: test
  image:
    name: node:${NODE_VERSION}-alpine
  needs:
    - job: build_frontend
      artifacts: false
      optional: false
  script:
    - echo "Linting frontend code"
    - cd frontend
    - npm ci
    - npm run lint
  allow_failure: true
  tags:
    - docker
lint_backend:
  stage: test
  image:
    name: golangci/golangci-lint:v1.55-alpine
  needs:
    - job: build_backend
      artifacts: false
      optional: false
  script:
    - echo "Linting backend code"
    - cd backend
    - golangci-lint run
  allow_failure: true
  tags:
    - docker
sast_scan:
  stage: security
  image:
    name: returntocorp/semgrep:latest
  needs: []
  script:
    - semgrep --config=auto --json --output=sast-report.json .
  artifacts:
    reports:
      sast: sast-report.json
  allow_failure: true
  tags:
    - docker
dependency_scan:
  stage: security
  image:
    name: aquasec/trivy:latest
  needs: []
  script:
    - trivy fs --format json --output dependency-report.json .
  artifacts:
    paths:
      - dependency-report.json
    expire_in: 1 week
  allow_failure: true
  tags:
    - docker
secret_scan:
  stage: security
  image:
    name: trufflesecurity/trufflehog:latest
  needs: []
  script:
    - trufflehog filesystem --directory=. --json > secrets-report.json
  artifacts:
    paths:
      - secrets-report.json
    expire_in: 1 week
  allow_failure: true
  tags:
    - docker
deploy_staging:
  stage: deploy
  image:
    name: alpine:latest
  needs:
    - job: test_frontend_unit
      artifacts: true
      optional: false
    - job: test_backend_unit
      artifacts: true
      optional: false
    - job: test_backend_integration
      artifacts: true
      optional: false
  before_script:
    - apk add --no-cache curl
  script:
    - echo "Deploying to staging"
    - curl -X POST "$STAGING_DEPLOY_WEBHOOK"
  environment:
    name: staging
    url: https://staging.example.com
    on_stop: stop_staging
    auto_stop_in: 7 days
  rules:
    - if: $CI_COMMIT_BRANCH == "develop"
  tags:
    - docker
stop_staging:
  stage: deploy
  image:
    name: alpine:latest
  before_script:
    - apk add --no-cache curl
  script:
    - echo "Stopping staging environment"
    - curl -X DELETE "$STAGING_DEPLOY_WEBHOOK"
  environment:
    name: staging
    action: stop
  when: manual
  rules:
    - if: $CI_COMMIT_BRANCH == "develop"
  tags:
    - docker
deploy_review:
  stage: deploy
  image:
    name: alpine:latest
  needs:
    - job: test_frontend_unit
      artifacts: true
      optional: false
    - job: test_backend_unit
      artifacts: true
      optional: false
  before_script:
    - apk add --no-cache curl
  script:
    - echo "Deploying review app"
    - echo "URL https://$CI_ENVIRONMENT_SLUG.review.example.com"
    - curl -X POST "$REVIEW_DEPLOY_WEBHOOK"
  environment:
    name: review/main
    url: https://review-ci-commit-ref-sl.review.example.com
    on_stop: stop_review
    auto_stop_in: 3 days
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
  tags:
    - docker
stop_review:
  stage: deploy
  image:
    name: alpine:latest
  before_script:
    - apk add --no-cache curl
  script:
    - echo "Stopping review app"
    - curl -X DELETE "$REVIEW_DEPLOY_WEBHOOK"
  environment:
    name: review/main
    action: stop
  when: manual
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
  tags:
    - docker
deploy_production:
  stage: deploy
  image:
    name: alpine:latest
  needs:
    - job: test_frontend_unit
      artifacts: true
      optional: false
    - job: test_backend_unit
      artifacts: true
      optional: false
    - job: test_backend_integration
      artifacts: true
      optional: false
    - job: sast_scan
      artifacts: true
      optional: false
    - job: dependency_scan
      artifacts: true
      optional: false
  before_script:
    - apk add --no-cache curl
  script:
    - echo "Deploying to production"
    - curl -X POST "$PRODUCTION_DEPLOY_WEBHOOK"
  environment:
    name: production
    url: https://example.com
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
      when: manual
  allow_failure: false
  tags:
    - docker
notify_deployment:
  stage: .post
  image:
    name: alpine:latest
  before_script:
    - apk add --no-cache curl
  script:
    - echo "Sending deployment notification"
    - |
      curl -X POST "$SLACK_WEBHOOK" \
        -H 'Content-Type: application/json' \
        -d "{\"text\":\"Pipeline completed: $CI_PIPELINE_URL\"}"
  when: always
  rules:
    - if: $CI_COMMIT_BRANCH == "main" || $CI_COMMIT_BRANCH == "develop"
  tags:
    - docker
default: {}
